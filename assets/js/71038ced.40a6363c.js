"use strict";(self.webpackChunkintegration_docs=self.webpackChunkintegration_docs||[]).push([[28],{1956:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api/examples","title":"API Examples","description":"This page provides complete, production-ready code examples for integrating with Rapido\'s Partner APIs across different programming languages and frameworks.","source":"@site/docs/api/examples.md","sourceDirName":"api","slug":"/api/examples","permalink":"/ota-docs/docs/api/examples","draft":false,"unlisted":false,"editUrl":"https://github.com/rapido-labs/ota-docs/tree/main/docs/docs/api/examples.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"API Examples","sidebar_label":"Code Examples","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Token Validation","permalink":"/ota-docs/docs/api/token-validation"},"next":{"title":"Security","permalink":"/ota-docs/docs/security"}}');var r=s(4848),o=s(8453);const i={title:"API Examples",sidebar_label:"Code Examples",sidebar_position:3},a="API Integration Examples",d={},l=[{value:"Complete Integration Example (Node.js)",id:"complete-integration-example-nodejs",level:2},{value:"Python/Django Example",id:"pythondjango-example",level:2},{value:"PHP/Laravel Example",id:"phplaravel-example",level:2},{value:"Error Handling Best Practices",id:"error-handling-best-practices",level:2},{value:"Comprehensive Error Handler (Node.js)",id:"comprehensive-error-handler-nodejs",level:3},{value:"Events API Examples",id:"events-api-examples",level:2},{value:"PWA Events Examples",id:"pwa-events-examples",level:3},{value:"PWA to Native Event Tracking",id:"pwa-to-native-event-tracking",level:4},{value:"Error Handling for PWA Events",id:"error-handling-for-pwa-events",level:4},{value:"Node.js Events Client",id:"nodejs-events-client",level:3},{value:"Coordinated Event Tracking",id:"coordinated-event-tracking",level:3},{value:"Testing Examples",id:"testing-examples",level:2},{value:"Session Management Integration Examples",id:"session-management-integration-examples",level:2},{value:"Complete Frontend + Backend Session Flow",id:"complete-frontend--backend-session-flow",level:3},{value:"Backend Session Validation with Cleanup",id:"backend-session-validation-with-cleanup",level:3},{value:"Unit Tests (Jest)",id:"unit-tests-jest",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"api-integration-examples",children:"API Integration Examples"})}),"\n",(0,r.jsx)(n.p,{children:"This page provides complete, production-ready code examples for integrating with Rapido's Partner APIs across different programming languages and frameworks."}),"\n",(0,r.jsx)(n.h2,{id:"complete-integration-example-nodejs",children:"Complete Integration Example (Node.js)"}),"\n",(0,r.jsx)(n.p,{children:"Here's a comprehensive Node.js implementation with Express.js:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const express = require('express');\nconst axios = require('axios');\nconst crypto = require('crypto');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Configuration\nconst config = {\n    rapido: {\n        apiKey: process.env.CLIENT_KEY,\n        clientId: process.env.CLIENT_ID,\n        baseURL: process.env.NODE_ENV === 'production' \n            ? '<rapido-host-url-prod>/api/ota'\n            : '<rapido-host-url-staging>/api/ota',\n        timeout: 10000\n    },\n    session: {\n        secret: process.env.SESSION_SECRET,\n        expiry: 24 * 60 * 60 * 1000 // 24 hours\n    }\n};\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Rate limiting\nconst authLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 50, // Limit each IP to 50 requests per windowMs\n    message: {\n        success: false,\n        error: 'Too many authentication attempts, please try again later'\n    }\n});\n\napp.use('/api/auth', authLimiter);\n\n// Rapido API Client\nclass RapidoAPIClient {\n    constructor(config) {\n        this.config = config;\n        this.axios = axios.create({\n            baseURL: config.baseURL,\n            timeout: config.timeout,\n            headers: {\n                'authorization': `${config.apiKey}`,\n                'Content-Type': 'application/json',\n                'User-Agent': 'PartnerApp/1.0.0'\n            }\n        });\n        \n        // Add request interceptor for logging\n        this.axios.interceptors.request.use(\n            (config) => {\n                console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);\n                return config;\n            },\n            (error) => {\n                console.error('API Request Error:', error);\n                return Promise.reject(error);\n            }\n        );\n        \n        // Add response interceptor for error handling\n        this.axios.interceptors.response.use(\n            (response) => {\n                console.log(`API Response: ${response.status} ${response.config.url}`);\n                return response;\n            },\n            (error) => {\n                this.handleAPIError(error);\n                return Promise.reject(error);\n            }\n        );\n    }\n    \n    async validateToken(token) {\n        const requestId = this.generateRequestId();\n        \n        try {\n            const response = await this.axios.post('/fetch-user-details', {\n                token: token\n            }, {\n                headers: {\n                    'x-client-id': this.config.clientId,\n                    'x-client-service': '<your_service_offering>',\n                    'x-client-appid': '<your_app_id>'\n                }\n            });\n            \n            return response.data;\n        } catch (error) {\n            console.error(`Token validation failed (${requestId}):`, error.message);\n            throw error;\n        }\n    }\n    \n    generateRequestId() {\n        return `req_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;\n    }\n    \n    handleAPIError(error) {\n        if (error.response) {\n            const { status, data } = error.response;\n            console.error(`API Error ${status}:`, data);\n            \n            // Add specific error handling based on status codes\n            switch (status) {\n                case 401:\n                    console.error('Unauthorized: Check API key configuration');\n                    break;\n                case 429:\n                    console.error('Rate limited: Slow down API requests');\n                    break;\n                case 503:\n                    console.error('Service unavailable: Rapido API is down');\n                    break;\n            }\n        } else if (error.request) {\n            console.error('Network Error: Unable to reach Rapido API');\n        }\n    }\n}\n\n// Database models (example with MongoDB/Mongoose)\nconst userSchema = {\n    rapidoUserId: String,\n    name: String,\n    email: String,\n    mobile: String,\n    profile: Object,\n    createdAt: { type: Date, default: Date.now },\n    lastLoginAt: Date\n};\n\nconst sessionSchema = {\n    sessionId: String,\n    userId: String,\n    expiresAt: Date,\n    createdAt: { type: Date, default: Date.now },\n    lastAccessedAt: Date\n};\n\n// Services\nclass UserService {\n    static async createOrUpdateUser(userData) {\n        // Implementation depends on your database\n        // This is a conceptual example\n        \n        const existingUser = await User.findOne({ \n            rapidoUserId: userData.id \n        });\n        \n        if (existingUser) {\n            // Update existing user\n            existingUser.name = userData.name;\n            existingUser.email = userData.email;\n            existingUser.mobile = userData.mobile;\n            existingUser.profile = userData.profile;\n            existingUser.lastLoginAt = new Date();\n            \n            return await existingUser.save();\n        } else {\n            // Create new user\n            const newUser = new User({\n                rapidoUserId: userData.id,\n                name: userData.name,\n                email: userData.email,\n                mobile: userData.mobile,\n                profile: userData.profile,\n                lastLoginAt: new Date()\n            });\n            \n            return await newUser.save();\n        }\n    }\n}\n\nclass SessionService {\n    static generateSessionId() {\n        return crypto.randomBytes(32).toString('hex');\n    }\n    \n    static async createSession(userId) {\n        const sessionId = this.generateSessionId();\n        const expiresAt = new Date(Date.now() + config.session.expiry);\n        \n        const session = new Session({\n            sessionId,\n            userId,\n            expiresAt,\n            lastAccessedAt: new Date()\n        });\n        \n        await session.save();\n        \n        return {\n            sessionId,\n            expiresAt\n        };\n    }\n    \n    static async validateSession(sessionId) {\n        const session = await Session.findOne({ \n            sessionId,\n            expiresAt: { $gt: new Date() }\n        });\n        \n        if (session) {\n            // Update last accessed time\n            session.lastAccessedAt = new Date();\n            await session.save();\n            \n            return {\n                valid: true,\n                userId: session.userId\n            };\n        } else {\n            // Clean up expired session\n            await Session.deleteOne({ sessionId });\n            return { valid: false };\n        }\n    }\n    \n    static async deleteSession(sessionId) {\n        await Session.deleteOne({ sessionId });\n    }\n}\n\n// Initialize Rapido API client\nconst rapidoAPI = new RapidoAPIClient(config.rapido);\n\n// Routes\napp.post('/api/auth/rapido-login', async (req, res) => {\n    try {\n        const { token } = req.body;\n        \n        // Validate request\n        if (!token) {\n            return res.status(400).json({\n                success: false,\n                error: 'Token is required'\n            });\n        }\n        \n        // Validate token with Rapido\n        const rapidoResponse = await rapidoAPI.validateToken(token);\n        \n        if (rapidoResponse.success && rapidoResponse.data.valid) {\n            const userData = rapidoResponse.data.user;\n            \n            // Create or update user\n            const user = await UserService.createOrUpdateUser(userData);\n            \n            // Create session\n            const sessionData = await SessionService.createSession(user._id);\n            \n            res.json({\n                success: true,\n                sessionId: sessionData.sessionId,\n                user: {\n                    id: user._id,\n                    name: user.name,\n                    email: user.email\n                },\n                expiresAt: sessionData.expiresAt\n            });\n            \n        } else {\n            res.status(401).json({\n                success: false,\n                error: 'Token validation failed'\n            });\n        }\n        \n    } catch (error) {\n        console.error('Authentication error:', error);\n        \n        // Return appropriate error based on error type\n        if (error.response?.status === 401) {\n            res.status(401).json({\n                success: false,\n                error: 'Invalid or expired token'\n            });\n        } else if (error.response?.status === 429) {\n            res.status(429).json({\n                success: false,\n                error: 'Rate limit exceeded. Please try again later.'\n            });\n        } else {\n            res.status(500).json({\n                success: false,\n                error: 'Authentication service temporarily unavailable'\n            });\n        }\n    }\n});\n\napp.post('/api/auth/validate-session', async (req, res) => {\n    try {\n        const { sessionId } = req.body;\n        \n        if (!sessionId) {\n            return res.json({ valid: false });\n        }\n        \n        const validation = await SessionService.validateSession(sessionId);\n        \n        res.json(validation);\n        \n    } catch (error) {\n        console.error('Session validation error:', error);\n        res.json({ valid: false });\n    }\n});\n\napp.post('/api/auth/logout', async (req, res) => {\n    try {\n        const { sessionId } = req.body;\n        \n        if (sessionId) {\n            await SessionService.deleteSession(sessionId);\n        }\n        \n        res.json({ success: true });\n        \n    } catch (error) {\n        console.error('Logout error:', error);\n        res.json({ success: true }); // Always return success for logout\n    }\n});\n\n// Health check endpoint\napp.get('/api/health', (req, res) => {\n    res.json({\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        environment: process.env.NODE_ENV || 'development'\n    });\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n    console.error('Unhandled error:', error);\n    \n    res.status(500).json({\n        success: false,\n        error: 'Internal server error'\n    });\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n});\n\nmodule.exports = app;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pythondjango-example",children:"Python/Django Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import os\nimport time\nimport hashlib\nimport secrets\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\n\nimport requests\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_http_methods\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django.conf import settings\nimport json\n\n# Configuration\nRAPIDO_CONFIG = {\n    'API_KEY': os.environ.get('CLIENT_KEY'),\n    'CLIENT_ID': os.environ.get('CLIENT_ID'),\n    'BASE_URL': '<rapido-host-url-prod>/api/ota' if os.environ.get('ENV') == 'production' \n               else '<rapido-host-url-staging>/api/ota',\n    'TIMEOUT': 10\n}\n\nclass RapidoAPIClient:\n    def __init__(self):\n        self.api_key = RAPIDO_CONFIG['API_KEY']\n        self.client_id = RAPIDO_CONFIG['CLIENT_ID']\n        self.base_url = RAPIDO_CONFIG['BASE_URL']\n        self.timeout = RAPIDO_CONFIG['TIMEOUT']\n    \n    def validate_token(self, token: str) -> Dict[str, Any]:\n        \"\"\"Validate token with Rapido API\"\"\"\n        \n        url = f\"{self.base_url}/fetch-user-details\"\n        headers = {\n            'authorization': f'{self.api_key}',\n            'Content-Type': 'application/json',\n            'User-Agent': 'PartnerApp/1.0.0',\n            'x-client-id': self.client_id,\n            'x-client-service': '<your_service_offering>',\n            'x-client-appid': '<your_app_id>'\n        }\n        data = {\n            'token': token\n        }\n        \n        try:\n            response = requests.post(\n                url, \n                json=data, \n                headers=headers, \n                timeout=self.timeout\n            )\n            \n            response.raise_for_status()\n            return response.json()\n            \n        except requests.exceptions.Timeout:\n            raise Exception(\"Rapido API timeout\")\n        except requests.exceptions.HTTPError as e:\n            self._handle_http_error(e.response)\n        except requests.exceptions.RequestException as e:\n            raise Exception(f\"Network error: {str(e)}\")\n    \n    def _generate_request_id(self) -> str:\n        timestamp = str(int(time.time()))\n        random_part = secrets.token_hex(8)\n        return f\"req_{timestamp}_{random_part}\"\n    \n    def _handle_http_error(self, response):\n        try:\n            error_data = response.json()\n            error_message = error_data.get('error', {}).get('message', 'API request failed')\n        except:\n            error_message = f\"HTTP {response.status_code}: {response.text}\"\n        \n        if response.status_code == 401:\n            raise Exception(\"Unauthorized: Invalid API key or token\")\n        elif response.status_code == 429:\n            raise Exception(\"Rate limit exceeded\")\n        else:\n            raise Exception(error_message)\n\n# Models (Django example)\nfrom django.db import models\nfrom django.contrib.auth.models import AbstractUser\n\nclass User(AbstractUser):\n    rapido_user_id = models.CharField(max_length=100, unique=True, null=True)\n    mobile = models.CharField(max_length=20, null=True)\n    profile_data = models.JSONField(default=dict)\n    last_login_at = models.DateTimeField(null=True)\n    \n    def save(self, *args, **kwargs):\n        if not self.last_login_at:\n            self.last_login_at = datetime.now()\n        super().save(*args, **kwargs)\n\nclass UserSession(models.Model):\n    session_id = models.CharField(max_length=64, unique=True)\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    expires_at = models.DateTimeField()\n    created_at = models.DateTimeField(auto_now_add=True)\n    last_accessed_at = models.DateTimeField(auto_now=True)\n    \n    @classmethod\n    def create_session(cls, user, duration_hours=24):\n        session_id = secrets.token_hex(32)\n        expires_at = datetime.now() + timedelta(hours=duration_hours)\n        \n        session = cls.objects.create(\n            session_id=session_id,\n            user=user,\n            expires_at=expires_at\n        )\n        \n        return session\n    \n    @classmethod\n    def validate_session(cls, session_id):\n        try:\n            session = cls.objects.get(\n                session_id=session_id,\n                expires_at__gt=datetime.now()\n            )\n            \n            # Update last accessed time\n            session.last_accessed_at = datetime.now()\n            session.save()\n            \n            return session\n        except cls.DoesNotExist:\n            return None\n\n# Views\n@method_decorator(csrf_exempt, name='dispatch')\nclass RapidoAuthView(View):\n    def __init__(self):\n        super().__init__()\n        self.rapido_client = RapidoAPIClient()\n    \n    def post(self, request):\n        try:\n            data = json.loads(request.body)\n            token = data.get('token')\n            \n            if not token:\n                return JsonResponse({\n                    'success': False,\n                    'error': 'Token is required'\n                }, status=400)\n            \n            # Validate token with Rapido\n            rapido_response = self.rapido_client.validate_token(token)\n            \n            if rapido_response.get('success') and rapido_response.get('data', {}).get('valid'):\n                user_data = rapido_response['data']['user']\n                \n                # Create or update user\n                user = self._create_or_update_user(user_data)\n                \n                # Create session\n                session = UserSession.create_session(user)\n                \n                return JsonResponse({\n                    'success': True,\n                    'sessionId': session.session_id,\n                    'user': {\n                        'id': user.id,\n                        'name': user.get_full_name(),\n                        'email': user.email\n                    },\n                    'expiresAt': session.expires_at.isoformat()\n                })\n            else:\n                return JsonResponse({\n                    'success': False,\n                    'error': 'Token validation failed'\n                }, status=401)\n                \n        except Exception as e:\n            return JsonResponse({\n                'success': False,\n                'error': str(e)\n            }, status=500)\n    \n    def _create_or_update_user(self, user_data):\n        try:\n            user = User.objects.get(rapido_user_id=user_data['id'])\n            # Update existing user\n            user.first_name = user_data.get('profile', {}).get('firstName', '')\n            user.last_name = user_data.get('profile', {}).get('lastName', '')\n            user.email = user_data.get('email', '')\n            user.mobile = user_data.get('mobile', '')\n            user.profile_data = user_data.get('profile', {})\n            user.last_login_at = datetime.now()\n            user.save()\n            \n        except User.DoesNotExist:\n            # Create new user\n            user = User.objects.create(\n                username=user_data['id'],  # Use Rapido ID as username\n                rapido_user_id=user_data['id'],\n                first_name=user_data.get('profile', {}).get('firstName', ''),\n                last_name=user_data.get('profile', {}).get('lastName', ''),\n                email=user_data.get('email', ''),\n                mobile=user_data.get('mobile', ''),\n                profile_data=user_data.get('profile', {}),\n                last_login_at=datetime.now()\n            )\n        \n        return user\n\n@method_decorator(csrf_exempt, name='dispatch')\nclass SessionValidateView(View):\n    def post(self, request):\n        try:\n            data = json.loads(request.body)\n            session_id = data.get('sessionId')\n            \n            if not session_id:\n                return JsonResponse({'valid': False})\n            \n            session = UserSession.validate_session(session_id)\n            \n            if session:\n                return JsonResponse({\n                    'valid': True,\n                    'userId': session.user.id\n                })\n            else:\n                return JsonResponse({'valid': False})\n                \n        except Exception as e:\n            return JsonResponse({'valid': False})\n\n# URL configuration (urls.py)\nfrom django.urls import path\n\nurlpatterns = [\n    path('api/auth/rapido-login', RapidoAuthView.as_view(), name='rapido_login'),\n    path('api/auth/validate-session', SessionValidateView.as_view(), name='validate_session'),\n]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"phplaravel-example",children:"PHP/Laravel Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"<?php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Http;\nuse Illuminate\\Support\\Facades\\Log;\nuse Exception;\n\nclass RapidoAPIService\n{\n    private $apiKey;\n    private $clientId;\n    private $baseUrl;\n    private $timeout;\n\n    public function __construct()\n    {\n        $this->apiKey = config('services.rapido.api_key');\n        $this->clientId = config('services.rapido.client_id');\n        $this->baseUrl = config('services.rapido.base_url');\n        $this->timeout = config('services.rapido.timeout', 10);\n    }\n\n    public function validateToken(string $token): array\n    {\n        $requestId = $this->generateRequestId();\n        \n        try {\n            $response = Http::withHeaders([\n                'authorization' => $this->apiKey,\n                'Content-Type' => 'application/json',\n                'User-Agent' => 'PartnerApp/1.0.0',\n                'x-client-id' => $this->clientId,\n                'x-client-service' => '<your_service_offering>',\n                'x-client-appid' => '<your_app_id>'\n            ])\n            ->timeout($this->timeout)\n            ->post($this->baseUrl . '/fetch-user-details', [\n                'token' => $token\n            ]);\n\n            if ($response->successful()) {\n                return $response->json();\n            } else {\n                $this->handleHttpError($response, $requestId);\n            }\n        } catch (Exception $e) {\n            Log::error(\"Rapido API error ({$requestId}): \" . $e->getMessage());\n            throw new Exception('Failed to validate token with Rapido API');\n        }\n    }\n\n    private function generateRequestId(): string\n    {\n        return 'req_' . time() . '_' . bin2hex(random_bytes(8));\n    }\n\n    private function handleHttpError($response, $requestId)\n    {\n        $status = $response->status();\n        $body = $response->json();\n        \n        Log::error(\"Rapido API HTTP error ({$requestId}): {$status}\", $body);\n        \n        switch ($status) {\n            case 401:\n                throw new Exception('Unauthorized: Invalid API key or token');\n            case 429:\n                throw new Exception('Rate limit exceeded');\n            default:\n                $message = $body['error']['message'] ?? 'API request failed';\n                throw new Exception($message);\n        }\n    }\n}\n\n// Controller\nnamespace App\\Http\\Controllers\\Auth;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Services\\RapidoAPIService;\nuse App\\Models\\User;\nuse App\\Models\\UserSession;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Str;\n\nclass RapidoAuthController extends Controller\n{\n    private $rapidoService;\n\n    public function __construct(RapidoAPIService $rapidoService)\n    {\n        $this->rapidoService = $rapidoService;\n    }\n\n    public function login(Request $request): JsonResponse\n    {\n        try {\n            $request->validate([\n                'token' => 'required|string'\n            ]);\n\n            $token = $request->input('token');\n            \n            // Validate token with Rapido\n            $rapidoResponse = $this->rapidoService->validateToken($token);\n            \n            if ($rapidoResponse['success'] && $rapidoResponse['data']['valid']) {\n                $userData = $rapidoResponse['data']['user'];\n                \n                // Create or update user\n                $user = $this->createOrUpdateUser($userData);\n                \n                // Create session\n                $session = UserSession::createSession($user);\n                \n                return response()->json([\n                    'success' => true,\n                    'sessionId' => $session->session_id,\n                    'user' => [\n                        'id' => $user->id,\n                        'name' => $user->name,\n                        'email' => $user->email,\n                    ],\n                    'expiresAt' => $session->expires_at->toISOString(),\n                ]);\n            } else {\n                return response()->json([\n                    'success' => false,\n                    'error' => 'Token validation failed'\n                ], 401);\n            }\n            \n        } catch (Exception $e) {\n            Log::error('Rapido authentication error: ' . $e->getMessage());\n            \n            return response()->json([\n                'success' => false,\n                'error' => 'Authentication failed'\n            ], 500);\n        }\n    }\n\n    public function validateSession(Request $request): JsonResponse\n    {\n        try {\n            $sessionId = $request->input('sessionId');\n            \n            if (!$sessionId) {\n                return response()->json(['valid' => false]);\n            }\n            \n            $session = UserSession::validateSession($sessionId);\n            \n            if ($session) {\n                return response()->json([\n                    'valid' => true,\n                    'userId' => $session->user_id\n                ]);\n            } else {\n                return response()->json(['valid' => false]);\n            }\n            \n        } catch (Exception $e) {\n            Log::error('Session validation error: ' . $e->getMessage());\n            return response()->json(['valid' => false]);\n        }\n    }\n\n    private function createOrUpdateUser(array $userData): User\n    {\n        $user = User::updateOrCreate(\n            ['rapido_user_id' => $userData['id']],\n            [\n                'name' => $userData['name'],\n                'email' => $userData['email'] ?? '',\n                'mobile' => $userData['mobile'] ?? '',\n                'profile_data' => $userData['profile'] ?? [],\n                'last_login_at' => now(),\n            ]\n        );\n\n        return $user;\n    }\n}\n\n// Model\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Support\\Str;\nuse Carbon\\Carbon;\n\nclass UserSession extends Model\n{\n    protected $fillable = [\n        'session_id',\n        'user_id',\n        'expires_at',\n    ];\n\n    protected $dates = [\n        'expires_at',\n        'last_accessed_at',\n    ];\n\n    public function user()\n    {\n        return $this->belongsTo(User::class);\n    }\n\n    public static function createSession(User $user, $durationHours = 24)\n    {\n        $sessionId = Str::random(64);\n        $expiresAt = Carbon::now()->addHours($durationHours);\n\n        return self::create([\n            'session_id' => $sessionId,\n            'user_id' => $user->id,\n            'expires_at' => $expiresAt,\n            'last_accessed_at' => Carbon::now(),\n        ]);\n    }\n\n    public static function validateSession($sessionId)\n    {\n        $session = self::where('session_id', $sessionId)\n                      ->where('expires_at', '>', Carbon::now())\n                      ->first();\n\n        if ($session) {\n            $session->update(['last_accessed_at' => Carbon::now()]);\n            return $session;\n        }\n\n        // Clean up expired session\n        self::where('session_id', $sessionId)->delete();\n        \n        return null;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-best-practices",children:"Error Handling Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-error-handler-nodejs",children:"Comprehensive Error Handler (Node.js)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class RapidoAPIError extends Error {\n    constructor(message, code, status, details = null) {\n        super(message);\n        this.name = 'RapidoAPIError';\n        this.code = code;\n        this.status = status;\n        this.details = details;\n    }\n}\n\nclass ErrorHandler {\n    static handleRapidoAPIError(error) {\n        if (error.response) {\n            const { status, data } = error.response;\n            const errorCode = data.error?.code || 'UNKNOWN_ERROR';\n            const errorMessage = data.error?.message || 'API request failed';\n            const errorDetails = data.error?.details || null;\n            \n            throw new RapidoAPIError(errorMessage, errorCode, status, errorDetails);\n        } else if (error.request) {\n            throw new RapidoAPIError(\n                'Network error: Unable to reach Rapido API',\n                'NETWORK_ERROR',\n                0\n            );\n        } else {\n            throw new RapidoAPIError(\n                error.message || 'Unknown error occurred',\n                'UNKNOWN_ERROR',\n                0\n            );\n        }\n    }\n    \n    static sendErrorResponse(res, error) {\n        let status = 500;\n        let errorResponse = {\n            success: false,\n            error: 'Internal server error'\n        };\n        \n        if (error instanceof RapidoAPIError) {\n            switch (error.code) {\n                case 'INVALID_TOKEN':\n                    status = 401;\n                    errorResponse.error = 'Invalid or expired token';\n                    break;\n                case 'UNAUTHORIZED':\n                    status = 401;\n                    errorResponse.error = 'Authentication failed';\n                    break;\n                case 'RATE_LIMITED':\n                    status = 429;\n                    errorResponse.error = 'Rate limit exceeded. Please try again later.';\n                    break;\n                case 'NETWORK_ERROR':\n                    status = 503;\n                    errorResponse.error = 'Authentication service temporarily unavailable';\n                    break;\n                default:\n                    status = error.status || 500;\n                    errorResponse.error = error.message;\n            }\n        }\n        \n        res.status(status).json(errorResponse);\n    }\n}\n\n// Usage in routes\napp.post('/api/auth/rapido-login', async (req, res) => {\n    try {\n        // ... authentication logic\n    } catch (error) {\n        console.error('Authentication error:', error);\n        ErrorHandler.sendErrorResponse(res, error);\n    }\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"events-api-examples",children:"Events API Examples"}),"\n",(0,r.jsx)(n.h3,{id:"pwa-events-examples",children:"PWA Events Examples"}),"\n",(0,r.jsx)(n.h4,{id:"pwa-to-native-event-tracking",children:"PWA to Native Event Tracking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Track user action with flat properties only\nfunction trackUserAction(actionName, additionalData = {}) {\n    const properties = {\n        action_name: actionName,\n        timestamp: new Date().toISOString(),\n        page_url: window.location.href,\n        user_agent: navigator.userAgent,\n        session_id: getCurrentSessionId(),\n        ...additionalData\n    };\n    \n    // Properties must be flat JSON - nested objects are not allowed\n    if (window.NativeJSBridge && window.NativeJSBridge.logEvents) {\n        window.NativeJSBridge.logEvents('user_action', JSON.stringify(properties));\n    }\n}\n\n// Track page view\nfunction trackPageView() {\n    const properties = {\n        page_name: document.title,\n        page_url: window.location.href,\n        referrer: document.referrer,\n        timestamp: new Date().toISOString(),\n        viewport_width: window.innerWidth,\n        viewport_height: window.innerHeight,\n        user_agent: navigator.userAgent\n    };\n    \n    window.NativeJSBridge.logEvents('page_view', JSON.stringify(properties));\n}\n\n// Track business event\nfunction trackBusinessEvent(eventType, businessData) {\n    const properties = {\n        event_type: eventType,\n        timestamp: new Date().toISOString(),\n        session_id: getCurrentSessionId(),\n        ...businessData  // All properties must be primitives (string, number, boolean)\n    };\n    \n    window.NativeJSBridge.logEvents('business_event', JSON.stringify(properties));\n}\n\n// Example usage with flat properties\ntrackUserAction('search_performed', {\n    search_query: 'flights to bangalore',\n    results_count: 45,\n    filter_economy: true,\n    filter_direct: true\n});\n\ntrackBusinessEvent('booking_initiated', {\n    service_type: 'flight',\n    origin: 'DEL',\n    destination: 'BLR',\n    departure_date: '2024-02-15',\n    estimated_price: 5500\n});\n\ntrackUserAction('filter_applied', {\n    filter_type: 'price_range',\n    min_price: 2000,\n    max_price: 8000,\n    currency: 'INR'\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"error-handling-for-pwa-events",children:"Error Handling for PWA Events"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function safeLogEvent(eventType, properties) {\n    try {\n        // Check if running in Rapido app\n        if (!window.NativeJSBridge) {\n            console.warn('Running outside Rapido app - event not logged');\n            return false;\n        }\n        \n        // Check if logEvents method is available\n        if (typeof window.NativeJSBridge.logEvents !== 'function') {\n            console.error('logEvents method not available');\n            return false;\n        }\n        \n        // Validate event type\n        if (!eventType || typeof eventType !== 'string') {\n            throw new Error('eventType must be a non-empty string');\n        }\n        \n        // Validate properties are flat (no nested objects)\n        if (properties && typeof properties === 'object') {\n            for (const [key, value] of Object.entries(properties)) {\n                if (value !== null && typeof value === 'object') {\n                    throw new Error(`Nested objects not allowed. Property '${key}' contains an object.`);\n                }\n            }\n        }\n        \n        // Convert to JSON string\n        const propertiesJson = JSON.stringify(properties || {});\n        \n        // Log the event\n        window.NativeJSBridge.logEvents(eventType, propertiesJson);\n        \n        return true;\n        \n    } catch (error) {\n        console.error('Failed to log event:', error);\n        \n        // Optional: Store for later retry\n        storeEventForLater(eventType, properties);\n        \n        return false;\n    }\n}\n\n// Helper function to store failed events for retry\nfunction storeEventForLater(eventType, properties) {\n    try {\n        const failedEvent = {\n            eventType,\n            properties,\n            timestamp: Date.now(),\n            retryCount: 0\n        };\n        \n        const failedEvents = JSON.parse(localStorage.getItem('rapido_failed_events') || '[]');\n        failedEvents.push(failedEvent);\n        \n        // Keep only last 50 failed events\n        if (failedEvents.length > 50) {\n            failedEvents.splice(0, failedEvents.length - 50);\n        }\n        \n        localStorage.setItem('rapido_failed_events', JSON.stringify(failedEvents));\n    } catch (storageError) {\n        console.error('Failed to store event for retry:', storageError);\n    }\n}\n\n// Retry failed events when bridge becomes available\nfunction retryFailedEvents() {\n    try {\n        const failedEvents = JSON.parse(localStorage.getItem('rapido_failed_events') || '[]');\n        const successfulEvents = [];\n        \n        failedEvents.forEach((event, index) => {\n            if (safeLogEvent(event.eventType, event.properties)) {\n                successfulEvents.push(index);\n            }\n        });\n        \n        // Remove successfully sent events\n        const remainingEvents = failedEvents.filter((_, index) => !successfulEvents.includes(index));\n        localStorage.setItem('rapido_failed_events', JSON.stringify(remainingEvents));\n        \n        if (successfulEvents.length > 0) {\n            console.log(`Successfully retried ${successfulEvents.length} failed events`);\n        }\n    } catch (error) {\n        console.error('Failed to retry stored events:', error);\n    }\n}\n\n// Usage with error handling\nsafeLogEvent('user_action', {\n    action_name: 'search_performed',\n    search_query: 'hotels in goa',\n    results_count: 23,\n    timestamp: new Date().toISOString()\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nodejs-events-client",children:"Node.js Events Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const axios = require('axios');\n\nclass RapidoEventClient {\n    constructor(clientId, clientKey, serviceType, appId) {\n        this.config = {\n            clientId,\n            clientKey,\n            serviceType,\n            appId,\n            baseURL: '<rapido-host-url>'\n        };\n    }\n\n    async postEvent(userId, eventType, eventId, attributes) {\n        try {\n            const eventData = {\n                userId: userId,\n                event: {\n                    type: eventType,\n                    id: eventId\n                },\n                attributes: attributes,\n                schemaVersion: 1\n            };\n\n            const response = await axios.post(\n                `${this.config.baseURL}/api/ota/event`,\n                eventData,\n                {\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'x-client-id': this.config.clientId,\n                        'x-client-service': this.config.serviceType,\n                        'x-client-app-id': this.config.appId,\n                        'authorization': this.config.clientKey\n                    }\n                }\n            );\n\n            if (response.data.success) {\n                console.log('Event posted successfully:', response.data.requestId);\n                return response.data;\n            } else {\n                throw new Error(`Event posting failed: ${response.data.error?.message}`);\n            }\n\n        } catch (error) {\n            console.error('Failed to post event to Rapido:', error);\n            throw error;\n        }\n    }\n\n    // Helper method for flight bookings\n    async postFlightBookingEvent(userId, orderId, orderStatus, bookingDetails) {\n        const eventId = `evt_flight_${orderId}_${Date.now()}`;\n        const attributes = {\n            orderId: orderId,\n            orderStatus: orderStatus,\n            amount_total: bookingDetails.totalAmount,\n            location_origin_lat: bookingDetails.origin.lat,\n            location_origin_long: bookingDetails.origin.lng,\n            location_dest_lat: bookingDetails.destination.lat,\n            location_dest_long: bookingDetails.destination.lng,\n            start_time: bookingDetails.departureTime,\n            end_time: bookingDetails.arrivalTime,\n            hostStatus: orderStatus === 'CONFIRMED' ? 'CONFIRMED' : 'CANCELLED',\n            tz: bookingDetails.timezone || 'Asia/Kolkata'\n        };\n\n        return await this.postEvent(userId, 'order.confirmed', eventId, attributes);\n    }\n\n    // Helper method for hotel bookings\n    async postHotelBookingEvent(userId, orderId, orderStatus, bookingDetails) {\n        const eventId = `evt_hotel_${orderId}_${Date.now()}`;\n        const attributes = {\n            orderId: orderId,\n            orderStatus: orderStatus,\n            amount_total: bookingDetails.totalAmount,\n            location_origin_lat: bookingDetails.hotel.lat,\n            location_origin_long: bookingDetails.hotel.lng,\n            location_dest_lat: bookingDetails.hotel.lat,\n            location_dest_long: bookingDetails.hotel.lng,\n            start_time: bookingDetails.checkInTime,\n            end_time: bookingDetails.checkOutTime,\n            hostStatus: orderStatus === 'CONFIRMED' ? 'CONFIRMED' : 'CANCELLED',\n            tz: bookingDetails.timezone || 'Asia/Kolkata'\n        };\n\n        return await this.postEvent(userId, 'order.confirmed', eventId, attributes);\n    }\n}\n\n// Usage example\nconst rapidoEvents = new RapidoEventClient(\n    'your-client-id',\n    'your-client-key', \n    'flights',\n    'your-app-id'\n);\n\n// Post flight booking confirmation\nasync function handleFlightBookingConfirmation(booking) {\n    try {\n        await rapidoEvents.postFlightBookingEvent(\n            booking.rapidoUserId,\n            booking.id,\n            'CONFIRMED',\n            {\n                totalAmount: booking.totalPrice,\n                origin: booking.originAirport.location,\n                destination: booking.destinationAirport.location,\n                departureTime: booking.departureTimestamp,\n                arrivalTime: booking.arrivalTimestamp,\n                timezone: booking.timezone\n            }\n        );\n\n        console.log('Flight booking event sent to Rapido successfully');\n    } catch (error) {\n        console.error('Failed to notify Rapido of booking confirmation:', error);\n        // Handle error appropriately (retry, alert, etc.)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"coordinated-event-tracking",children:"Coordinated Event Tracking"}),"\n",(0,r.jsx)(n.p,{children:"Here's how both PWA-to-Native and Server-to-Server events work together in a complete booking flow:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Frontend PWA - Track user interactions\nclass BookingEventTracker {\n    constructor() {\n        this.sessionId = this.getSessionId();\n        this.rapidoEventClient = new RapidoServerEventClient();\n    }\n\n    // PWA to Native events\n    trackSearchInitiated(searchParams) {\n        safeLogEvent('search_initiated', {\n            service_type: searchParams.service,\n            origin: searchParams.origin,\n            destination: searchParams.destination,\n            departure_date: searchParams.departureDate,\n            return_date: searchParams.returnDate,\n            passengers: searchParams.passengers,\n            session_id: this.sessionId,\n            timestamp: new Date().toISOString()\n        });\n    }\n\n    trackResultsViewed(resultsData) {\n        safeLogEvent('results_viewed', {\n            service_type: resultsData.service,\n            results_count: resultsData.totalResults,\n            filters_applied: resultsData.appliedFilters,\n            sort_order: resultsData.sortOrder,\n            session_id: this.sessionId,\n            timestamp: new Date().toISOString()\n        });\n    }\n\n    trackBookingInitiated(bookingData) {\n        safeLogEvent('booking_initiated', {\n            service_type: bookingData.service,\n            selected_option_id: bookingData.optionId,\n            estimated_price: bookingData.price,\n            session_id: this.sessionId,\n            timestamp: new Date().toISOString()\n        });\n    }\n\n    // Coordinate with backend events\n    async handleBookingConfirmation(bookingResult) {\n        // Track frontend completion\n        safeLogEvent('booking_completed', {\n            booking_id: bookingResult.bookingId,\n            final_price: bookingResult.totalAmount,\n            payment_method: bookingResult.paymentMethod,\n            session_id: this.sessionId,\n            timestamp: new Date().toISOString()\n        });\n\n        // Trigger server-to-server event\n        try {\n            await this.rapidoEventClient.postBookingConfirmation(bookingResult);\n        } catch (error) {\n            console.error('Failed to post server event:', error);\n            // Log failure for monitoring\n            safeLogEvent('server_event_failed', {\n                booking_id: bookingResult.bookingId,\n                error_message: error.message,\n                timestamp: new Date().toISOString()\n            });\n        }\n    }\n}\n\n// Backend - Server to Server events\nclass RapidoServerEventClient {\n    constructor() {\n        this.client = new RapidoEventClient(\n            process.env.RAPIDO_CLIENT_ID,\n            process.env.RAPIDO_CLIENT_KEY,\n            process.env.SERVICE_TYPE,\n            process.env.APP_ID\n        );\n    }\n\n    async postBookingConfirmation(bookingData) {\n        const eventDetails = this.prepareBookingEventData(bookingData);\n        \n        return await this.client.postFlightBookingEvent(\n            bookingData.rapidoUserId,\n            bookingData.bookingId,\n            'CONFIRMED',\n            eventDetails\n        );\n    }\n\n    prepareBookingEventData(booking) {\n        return {\n            totalAmount: booking.totalAmount,\n            origin: {\n                lat: booking.origin.latitude,\n                lng: booking.origin.longitude\n            },\n            destination: {\n                lat: booking.destination.latitude, \n                lng: booking.destination.longitude\n            },\n            departureTime: booking.departureTimestamp,\n            arrivalTime: booking.arrivalTimestamp,\n            timezone: booking.timezone || 'Asia/Kolkata'\n        };\n    }\n}\n\n// Usage in booking flow\nconst eventTracker = new BookingEventTracker();\n\n// User searches for flights\neventTracker.trackSearchInitiated({\n    service: 'flight',\n    origin: 'DEL',\n    destination: 'BLR',\n    departureDate: '2024-02-15',\n    passengers: 2\n});\n\n// User views results\neventTracker.trackResultsViewed({\n    service: 'flight',\n    totalResults: 45,\n    appliedFilters: ['economy', 'morning'],\n    sortOrder: 'price_low_high'\n});\n\n// User initiates booking\neventTracker.trackBookingInitiated({\n    service: 'flight',\n    optionId: 'flight_123',\n    price: 8500\n});\n\n// Booking confirmed - coordinate both event types\neventTracker.handleBookingConfirmation({\n    bookingId: 'FL_BOOKING_ABC123',\n    rapidoUserId: 'rapido_user_12345',\n    totalAmount: 8500,\n    paymentMethod: 'credit_card',\n    origin: { latitude: 28.5562, longitude: 77.1000 },\n    destination: { latitude: 12.9716, longitude: 77.5946 },\n    departureTimestamp: 1708156800,\n    arrivalTimestamp: 1708163000,\n    timezone: 'Asia/Kolkata'\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"This coordinated approach ensures:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complete User Journey Tracking"}),": PWA events capture user interactions and decision-making"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Business Event Reliability"}),": Server events ensure critical business events are recorded"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Consistency"}),": Both flows share common identifiers (session IDs, booking IDs)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failure Resilience"}),": Frontend events continue even if server events fail"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"testing-examples",children:"Testing Examples"}),"\n",(0,r.jsx)(n.h2,{id:"session-management-integration-examples",children:"Session Management Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"complete-frontend--backend-session-flow",children:"Complete Frontend + Backend Session Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Frontend session management with Rapido JSBridge\nclass RapidoSessionManager {\n    constructor() {\n        this.setupCallbacks();\n    }\n    \n    setupCallbacks() {\n        // Set up session ID callback\n        window.JSBridge.onSessionIdReceived = (sessionId) => {\n            if (sessionId && sessionId !== 'null') {\n                console.log('Stored session found');\n                this.validateSession(sessionId);\n            } else {\n                console.log('No stored session - requesting authentication');\n                this.requestAuthentication();\n            }\n        };\n        \n        // Set up token callback\n        window.JSBridge.onTokenReceived = (token) => {\n            this.processAuthToken(token);\n        };\n    }\n    \n    // Check for existing session on app load\n    checkExistingSession() {\n        if (window.NativeJSBridge && window.NativeJSBridge.requestSessionId) {\n            window.NativeJSBridge.requestSessionId();\n        } else {\n            this.requestAuthentication();\n        }\n    }\n    \n    async validateSession(sessionId) {\n        try {\n            const response = await fetch('/api/auth/validate-session', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ sessionId })\n            });\n            \n            const result = await response.json();\n            \n            if (result.valid) {\n                this.redirectToDashboard();\n            } else {\n                // Session expired - clear and request new auth\n                this.clearSession();\n                this.requestAuthentication();\n            }\n        } catch (error) {\n            console.error('Session validation failed:', error);\n            this.requestAuthentication();\n        }\n    }\n    \n    requestAuthentication() {\n        if (window.NativeJSBridge && window.NativeJSBridge.requestUserToken) {\n            window.NativeJSBridge.requestUserToken({ scope: [\"profile\"] });\n        }\n    }\n    \n    async processAuthToken(token) {\n        try {\n            const response = await fetch('/api/auth/rapido-login', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ token })\n            });\n            \n            const result = await response.json();\n            \n            if (result.success) {\n                // Store session ID securely\n                this.storeSession(result.sessionId);\n                \n                // Notify native app\n                if (window.NativeJSBridge && window.NativeJSBridge.updateLoginStatus) {\n                    window.NativeJSBridge.updateLoginStatus(true, null);\n                }\n                \n                this.redirectToDashboard();\n            } else {\n                throw new Error(result.error || 'Authentication failed');\n            }\n        } catch (error) {\n            console.error('Authentication failed:', error);\n            \n            // Notify native app of failure\n            if (window.NativeJSBridge && window.NativeJSBridge.updateLoginStatus) {\n                window.NativeJSBridge.updateLoginStatus(false, error.message);\n            }\n        }\n    }\n    \n    storeSession(sessionId) {\n        if (window.NativeJSBridge && window.NativeJSBridge.storeSessionId) {\n            const result = window.NativeJSBridge.storeSessionId(sessionId);\n            if (result === 'SUCCESS') {\n                console.log('Session stored successfully');\n            }\n        }\n    }\n    \n    clearSession() {\n        if (window.NativeJSBridge && window.NativeJSBridge.clearUserToken) {\n            window.NativeJSBridge.clearUserToken();\n        }\n    }\n    \n    redirectToDashboard() {\n        window.location.href = '/dashboard';\n    }\n}\n\n// Initialize session manager\nconst sessionManager = new RapidoSessionManager();\n\n// Check for existing session on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    sessionManager.checkExistingSession();\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"backend-session-validation-with-cleanup",children:"Backend Session Validation with Cleanup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Enhanced session service with automatic cleanup\nclass SessionService {\n    static generateSessionId() {\n        return crypto.randomBytes(32).toString('hex');\n    }\n    \n    static async createSession(userId, metadata = {}) {\n        const sessionId = this.generateSessionId();\n        const expiresAt = new Date(Date.now() + config.session.expiry);\n        \n        // Clean up any existing sessions for this user\n        await Session.deleteMany({ \n            userId,\n            expiresAt: { $lt: new Date() }\n        });\n        \n        const session = new Session({\n            sessionId,\n            userId,\n            expiresAt,\n            metadata,\n            lastAccessedAt: new Date(),\n            userAgent: metadata.userAgent || 'Unknown',\n            ipAddress: metadata.ipAddress || 'Unknown'\n        });\n        \n        await session.save();\n        \n        // Schedule cleanup job\n        this.scheduleSessionCleanup(sessionId, expiresAt);\n        \n        return {\n            sessionId,\n            expiresAt\n        };\n    }\n    \n    static async validateSession(sessionId) {\n        const session = await Session.findOne({ \n            sessionId,\n            expiresAt: { $gt: new Date() }\n        }).populate('user');\n        \n        if (session) {\n            // Update last accessed time\n            session.lastAccessedAt = new Date();\n            await session.save();\n            \n            return {\n                valid: true,\n                userId: session.userId,\n                user: session.user,\n                metadata: session.metadata\n            };\n        } else {\n            // Clean up expired session\n            await Session.deleteOne({ sessionId });\n            return { valid: false };\n        }\n    }\n    \n    static async deleteSession(sessionId) {\n        await Session.deleteOne({ sessionId });\n    }\n    \n    static async cleanupExpiredSessions() {\n        const result = await Session.deleteMany({\n            expiresAt: { $lt: new Date() }\n        });\n        \n        console.log(`Cleaned up ${result.deletedCount} expired sessions`);\n        return result.deletedCount;\n    }\n    \n    static scheduleSessionCleanup(sessionId, expiresAt) {\n        const timeUntilExpiry = expiresAt.getTime() - Date.now();\n        \n        setTimeout(async () => {\n            await this.deleteSession(sessionId);\n            console.log(`Auto-cleaned expired session: ${sessionId}`);\n        }, timeUntilExpiry);\n    }\n}\n\n// Enhanced session validation route\napp.post('/api/auth/validate-session', async (req, res) => {\n    try {\n        const { sessionId } = req.body;\n        \n        if (!sessionId) {\n            return res.json({ valid: false });\n        }\n        \n        const validation = await SessionService.validateSession(sessionId);\n        \n        if (validation.valid) {\n            res.json({\n                valid: true,\n                userId: validation.userId,\n                user: {\n                    id: validation.user._id,\n                    name: validation.user.name,\n                    email: validation.user.email\n                }\n            });\n        } else {\n            res.json({ valid: false });\n        }\n        \n    } catch (error) {\n        console.error('Session validation error:', error);\n        res.json({ valid: false });\n    }\n});\n\n// Session cleanup cron job (run every hour)\nconst cron = require('node-cron');\n\ncron.schedule('0 * * * *', async () => {\n    try {\n        await SessionService.cleanupExpiredSessions();\n    } catch (error) {\n        console.error('Session cleanup error:', error);\n    }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"unit-tests-jest",children:"Unit Tests (Jest)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const RapidoAPIClient = require('../src/services/RapidoAPIClient');\nconst axios = require('axios');\n\njest.mock('axios');\nconst mockedAxios = axios;\n\ndescribe('RapidoAPIClient', () => {\n    let client;\n    \n    beforeEach(() => {\n        client = new RapidoAPIClient({\n            apiKey: 'test-api-key',\n            clientId: 'test-client-id',\n            baseURL: 'https://test-api.rapido.bike/partner'\n        });\n    });\n    \n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n    \n    describe('validateToken', () => {\n        it('should successfully validate a valid token', async () => {\n            const mockResponse = {\n                data: {\n                    success: true,\n                    data: {\n                        valid: true,\n                        user: {\n                            id: 'user_123',\n                            name: 'John Doe',\n                            email: 'john@example.com'\n                        }\n                    }\n                }\n            };\n            \n            mockedAxios.post.mockResolvedValue(mockResponse);\n            \n            const result = await client.validateToken('valid-token');\n            \n            expect(result.success).toBe(true);\n            expect(result.data.valid).toBe(true);\n            expect(result.data.user.id).toBe('user_123');\n            \n            expect(mockedAxios.post).toHaveBeenCalledWith(\n                '/fetch-user-details',\n                {\n                    token: 'valid-token'\n                },\n                expect.objectContaining({\n                    headers: expect.objectContaining({\n                        'x-client-id': 'test_client_id'\n                    })\n                })\n            );\n        });\n        \n        it('should handle invalid token error', async () => {\n            const mockError = {\n                response: {\n                    status: 401,\n                    data: {\n                        success: false,\n                        error: {\n                            code: 'INVALID_TOKEN',\n                            message: 'Token is invalid or expired'\n                        }\n                    }\n                }\n            };\n            \n            mockedAxios.post.mockRejectedValue(mockError);\n            \n            await expect(client.validateToken('invalid-token'))\n                .rejects\n                .toThrow('Token is invalid or expired');\n        });\n        \n        it('should handle network errors', async () => {\n            const mockError = {\n                request: {}\n            };\n            \n            mockedAxios.post.mockRejectedValue(mockError);\n            \n            await expect(client.validateToken('some-token'))\n                .rejects\n                .toThrow('Network error: Unable to reach Rapido API');\n        });\n    });\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Related Documentation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ota-docs/docs/api/overview",children:"API Overview"})," - Complete API documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ota-docs/docs/api/token-validation",children:"Token Validation API"})," - Detailed endpoint specifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ota-docs/docs/integration/basics",children:"Integration Basics"})," - Frontend integration guide"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);